/**
 * Copyright (c) Tiny Technologies, Inc. All rights reserved.
 * Licensed under the LGPL or a commercial license.
 * For LGPL see License.txt in the project root for license information.
 * For commercial licenses see https://www.tiny.cloud/
 *
 * Version: 5.10.2 (2021-11-17)
 */
(function () {
    'use strict';

    /*var Cell = function (initial) {
      var value = initial;
      var get = function () {
        return value;
      };
      var set = function (v) {
        value = v;
      };
      return {
        get: get,
        set: set
      };
    };*/

	const Cell = initial => {
		let value = initial;
		const get = () => {
		  return value;
		};
		const set = v => {
		  value = v;
		};
		return {
		  get,
		  set
		};
	  };

    var pluginGlobal$4 = tinymce.util.Tools.resolve('tinymce.PluginManager');

    var __assign = function () {
      __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };

    var pluginGlobal$3 = tinymce.util.Tools.resolve('tinymce.util.Tools');

    var pluginGlobal$2 = tinymce.util.Tools.resolve('tinymce.html.DomParser');

    var pluginGlobal$1 = tinymce.util.Tools.resolve('tinymce.html.Node');

    var pluginGlobal = tinymce.util.Tools.resolve('tinymce.html.Serializer');

    // var Schema = tinymce.util.Tools.resolve('tinymce.html.Schema');
    //var Schema = Schema();

	var Tools = tinymce.util.Tools;

    var shouldHideInSourceView = function (editor) {
      return editor.getParam('fullpage_hide_in_source_view');
    };
    var getDefaultXmlPi = function (editor) {
      return editor.getParam('fullpage_default_xml_pi');
    };
    var getDefaultEncoding = function (editor) {
      return editor.getParam('fullpage_default_encoding');
    };
    var getDefaultFontFamily = function (editor) {
      return editor.getParam('fullpage_default_font_family');
    };
    var getDefaultFontSize = function (editor) {
      return editor.getParam('fullpage_default_font_size');
    };
    var getDefaultTextColor = function (editor) {
      return editor.getParam('fullpage_default_text_color');
    };
    var getDefaultTitle = function (editor) {
      return editor.getParam('fullpage_default_title');
    };
    var getDefaultDocType = function (editor) {
      return editor.getParam('fullpage_default_doctype', '<!DOCTYPE html>');
    };
    var getProtect = function (editor) {
      return editor.getParam('protect');
    };

    var parseHeader = function (editor, head) {
    //   var $return = pluginGlobal$2({
      var $return = DomParser({
        validate: false,
        root_name: '#document'
      }/*, editor.schema*/).parse(head, { format: 'xhtml' });
      //}, editor.schema).parse(head, { format: 'xhtml' });
	  return $return;
    };
    var htmlToData = function (editor, head) {
      var headerFragment = parseHeader(editor, head);
      var data = {};
      var elm, matches;
      var getAttr = function (elm, name) {
        var value = elm.attr(name);
        return value || '';
      };
      data.fontface = getDefaultFontFamily(editor);
      data.fontsize = getDefaultFontSize(editor);
      elm = headerFragment.firstChild;
      if (elm.type === 7) {
        data.xml_pi = true;
        matches = /encoding="([^"]+)"/.exec(elm.value);
        if (matches) {
          data.docencoding = matches[1];
        }
      }
      elm = headerFragment.getAll('#doctype')[0];
      if (elm) {
        data.doctype = '<!DOCTYPE' + elm.value + '>';
      }
      elm = headerFragment.getAll('title')[0];
      if (elm && elm.firstChild) {
        data.title = elm.firstChild.value;
      }
      pluginGlobal$3.each(headerFragment.getAll('meta'), function (meta) {
        var name = meta.attr('name');
        var httpEquiv = meta.attr('http-equiv');
        var matches;
        if (name) {
          data[name.toLowerCase()] = meta.attr('content');
        } else if (httpEquiv === 'Content-Type') {
          matches = /charset\s*=\s*(.*)\s*/gi.exec(meta.attr('content'));
          if (matches) {
            data.docencoding = matches[1];
          }
        }
      });
      elm = headerFragment.getAll('html')[0];
      if (elm) {
        data.langcode = getAttr(elm, 'lang') || getAttr(elm, 'xml:lang');
      }
      data.stylesheets = [];
      pluginGlobal$3.each(headerFragment.getAll('link'), function (link) {
        if (link.attr('rel') === 'stylesheet') {
          data.stylesheets.push(link.attr('href'));
        }
      });
      elm = headerFragment.getAll('body')[0];
      if (elm) {
        data.langdir = getAttr(elm, 'dir');
        data.style = getAttr(elm, 'style');
        data.visited_color = getAttr(elm, 'vlink');
        data.link_color = getAttr(elm, 'link');
        data.active_color = getAttr(elm, 'alink');
      }
      return data;
    };
    var dataToHtml = function (editor, data, head) {
      var headElement, elm;
      var dom = editor.dom;
      var setAttr = function (elm, name, value) {
        elm.attr(name, value ? value : undefined);
      };
      var addHeadNode = function (node) {
        if (headElement.firstChild) {
          headElement.insert(node, headElement.firstChild);
        } else {
          headElement.append(node);
        }
      };
      var headerFragment = parseHeader(editor, head);
      headElement = headerFragment.getAll('head')[0];
      if (!headElement) {
        elm = headerFragment.getAll('html')[0];
        headElement = new pluginGlobal$1('head', 1);
        if (elm.firstChild) {
          elm.insert(headElement, elm.firstChild, true);
        } else {
          elm.append(headElement);
        }
      }
      elm = headerFragment.firstChild;
      if (data.xml_pi) {
        var value = 'version="1.0"';
        if (data.docencoding) {
          value += ' encoding="' + data.docencoding + '"';
        }
        if (elm.type !== 7) {
          elm = new pluginGlobal$1('xml', 7);
          headerFragment.insert(elm, headerFragment.firstChild, true);
        }
        elm.value = value;
      } else if (elm && elm.type === 7) {
        elm.remove();
      }
      elm = headerFragment.getAll('#doctype')[0];
      if (data.doctype) {
        if (!elm) {
          elm = new pluginGlobal$1('#doctype', 10);
          if (data.xml_pi) {
            headerFragment.insert(elm, headerFragment.firstChild);
          } else {
            addHeadNode(elm);
          }
        }
        elm.value = data.doctype.substring(9, data.doctype.length - 1);
      } else if (elm) {
        elm.remove();
      }
      elm = null;
      pluginGlobal$3.each(headerFragment.getAll('meta'), function (meta) {
        if (meta.attr('http-equiv') === 'Content-Type') {
          elm = meta;
        }
      });
      if (data.docencoding) {
        if (!elm) {
          elm = new pluginGlobal$1('meta', 1);
          elm.attr('http-equiv', 'Content-Type');
          elm.shortEnded = true;
          addHeadNode(elm);
        }
        elm.attr('content', 'text/html; charset=' + data.docencoding);
      } else if (elm) {
        elm.remove();
      }
      elm = headerFragment.getAll('title')[0];
      if (data.title) {
        if (!elm) {
          elm = new pluginGlobal$1('title', 1);
          addHeadNode(elm);
        } else {
          elm.empty();
        }
        elm.append(new pluginGlobal$1('#text', 3)).value = data.title;
      } else if (elm) {
        elm.remove();
      }
      pluginGlobal$3.each('keywords,description,author,copyright,robots'.split(','), function (name) {
        var nodes = headerFragment.getAll('meta');
        var i, meta;
        var value = data[name];
        for (i = 0; i < nodes.length; i++) {
          meta = nodes[i];
          if (meta.attr('name') === name) {
            if (value) {
              meta.attr('content', value);
            } else {
              meta.remove();
            }
            return;
          }
        }
        if (value) {
          elm = new pluginGlobal$1('meta', 1);
          elm.attr('name', name);
          elm.attr('content', value);
          elm.shortEnded = true;
          addHeadNode(elm);
        }
      });
      var currentStyleSheetsMap = {};
      pluginGlobal$3.each(headerFragment.getAll('link'), function (stylesheet) {
        if (stylesheet.attr('rel') === 'stylesheet') {
          currentStyleSheetsMap[stylesheet.attr('href')] = stylesheet;
        }
      });
      pluginGlobal$3.each(data.stylesheets, function (stylesheet) {
        if (!currentStyleSheetsMap[stylesheet]) {
          elm = new pluginGlobal$1('link', 1);
          elm.attr({
            rel: 'stylesheet',
            text: 'text/css',
            href: stylesheet
          });
          elm.shortEnded = true;
          addHeadNode(elm);
        }
        delete currentStyleSheetsMap[stylesheet];
      });
      pluginGlobal$3.each(currentStyleSheetsMap, function (stylesheet) {
        stylesheet.remove();
      });
      elm = headerFragment.getAll('body')[0];
      if (elm) {
        setAttr(elm, 'dir', data.langdir);
        setAttr(elm, 'style', data.style);
        setAttr(elm, 'vlink', data.visited_color);
        setAttr(elm, 'link', data.link_color);
        setAttr(elm, 'alink', data.active_color);
        dom.setAttribs(editor.getBody(), {
          style: data.style,
          dir: data.dir,
          vLink: data.visited_color,
          link: data.link_color,
          aLink: data.active_color
        });
      }
      elm = headerFragment.getAll('html')[0];
      if (elm) {
        setAttr(elm, 'lang', data.langcode);
        setAttr(elm, 'xml:lang', data.langcode);
      }
      if (!headElement.firstChild) {
        headElement.remove();
      }
      var html = pluginGlobal({
        validate: false,
        indent: true,
        indent_before: 'head,html,body,meta,title,script,link,style',
        indent_after: 'head,html,body,meta,title,script,link,style'
      }).serialize(headerFragment);
      return html.substring(0, html.indexOf('</body>'));
    };

    var open = function (editor, headState) {
      var data = htmlToData(editor, headState.get());
      var defaultData = {
        title: '',
        keywords: '',
        description: '',
        robots: '',
        author: '',
        docencoding: ''
      };
      var initialData = __assign(__assign({}, defaultData), data);
      editor.windowManager.open({
        title: 'Metadata and Document Properties',
        size: 'normal',
        body: {
          type: 'panel',
          items: [
            {
              name: 'title',
              type: 'input',
              label: 'Title'
            },
            {
              name: 'keywords',
              type: 'input',
              label: 'Keywords'
            },
            {
              name: 'description',
              type: 'input',
              label: 'Description'
            },
            {
              name: 'robots',
              type: 'input',
              label: 'Robots'
            },
            {
              name: 'author',
              type: 'input',
              label: 'Author'
            },
            {
              name: 'docencoding',
              type: 'input',
              label: 'Encoding'
            }
          ]
        },
        buttons: [
          {
            type: 'cancel',
            name: 'cancel',
            text: 'Cancel'
          },
          {
            type: 'submit',
            name: 'save',
            text: 'Save',
            primary: true
          }
        ],
        initialData: initialData,
        onSubmit: function (api) {
          var nuData = api.getData();
          var headHtml = dataToHtml(editor, pluginGlobal$3.extend(data, nuData), headState.get());
          headState.set(headHtml);
          api.close();
        }
      });
    };

    var pluginRegister$1 = function (editor, headState) {
      editor.addCommand('mceFullPageProperties', function () {
        open(editor, headState);
      });
    };

    var protectHtml = function (protect, html) {
		pluginGlobal$3.each(protect, function (pattern) {
        html = html.replace(pattern, function (str) {
          return '<!--mce:protected ' + escape(str) + '-->';
        });
      });
      return html;
    };
    var unprotectHtml = function (html) {
      return html.replace(/<!--mce:protected ([\s\S]*?)-->/g, function (a, m) {
        return unescape(m);
      });
    };

    var each = pluginGlobal$3.each;
    var low = function (s) {
      return s.replace(/<\/?[A-Z]+/g, function (a) {
        return a.toLowerCase();
      });
    };
    var handleSetContent = function (editor, headState, footState, evt) {
      var startPos, endPos, content, styles = '';
      var dom = editor.dom;
      if (evt.selection) {
        return;
      }
      content = protectHtml(getProtect(editor), evt.content);
      if (evt.format === 'raw' && headState.get()) {
        return;
      }
      if (evt.source_view && shouldHideInSourceView(editor)) {
        return;
      }
      if (content.length === 0 && !evt.source_view) {
        content = pluginGlobal$3.trim(headState.get()) + '\n' + pluginGlobal$3.trim(content) + '\n' + pluginGlobal$3.trim(footState.get());
      }
      content = content.replace(/<(\/?)BODY/gi, '<$1body');
      startPos = content.indexOf('<body');
      if (startPos !== -1) {
        startPos = content.indexOf('>', startPos);
        headState.set(low(content.substring(0, startPos + 1)));
        endPos = content.indexOf('</body', startPos);
        if (endPos === -1) {
          endPos = content.length;
        }
        evt.content = pluginGlobal$3.trim(content.substring(startPos + 1, endPos));
        footState.set(low(content.substring(endPos)));
      } else {
        headState.set(getDefaultHeader(editor));
        footState.set('\n</body>\n</html>');
      }
      var headerFragment = parseHeader(editor, headState.get());
      each(headerFragment.getAll('style'), function (node) {
        if (node.firstChild) {
          styles += node.firstChild.value;
        }
      });
      var bodyElm = headerFragment.getAll('body')[0];
      if (bodyElm) {
        dom.setAttribs(editor.getBody(), {
          style: bodyElm.attr('style') || '',
          dir: bodyElm.attr('dir') || '',
          vLink: bodyElm.attr('vlink') || '',
          link: bodyElm.attr('link') || '',
          aLink: bodyElm.attr('alink') || ''
        });
      }
      dom.remove('fullpage_styles');
      var headElm = editor.getDoc().getElementsByTagName('head')[0];
      if (styles) {
        var styleElm = dom.add(headElm, 'style', { id: 'fullpage_styles' });
        styleElm.appendChild(document.createTextNode(styles));
      }
      var currentStyleSheetsMap = {};
      pluginGlobal$3.each(headElm.getElementsByTagName('link'), function (stylesheet) {
        if (stylesheet.rel === 'stylesheet' && stylesheet.getAttribute('data-mce-fullpage')) {
          currentStyleSheetsMap[stylesheet.href] = stylesheet;
        }
      });
      pluginGlobal$3.each(headerFragment.getAll('link'), function (stylesheet) {
        var href = stylesheet.attr('href');
        if (!href) {
          return true;
        }
        if (!currentStyleSheetsMap[href] && stylesheet.attr('rel') === 'stylesheet') {
          dom.add(headElm, 'link', {
            'rel': 'stylesheet',
            'text': 'text/css',
            href: href,
            'data-mce-fullpage': '1'
          });
        }
        delete currentStyleSheetsMap[href];
      });
      pluginGlobal$3.each(currentStyleSheetsMap, function (stylesheet) {
        stylesheet.parentNode.removeChild(stylesheet);
      });
    };
    var getDefaultHeader = function (editor) {
      var header = '', value, styles = '';
      if (getDefaultXmlPi(editor)) {
        var piEncoding = getDefaultEncoding(editor);
        header += '<?xml version="1.0" encoding="' + (piEncoding ? piEncoding : 'ISO-8859-1') + '" ?>\n';
      }
      header += getDefaultDocType(editor);
      header += '\n<html>\n<head>\n';
      if (value = getDefaultTitle(editor)) {
        header += '<title>' + value + '</title>\n';
      }
      if (value = getDefaultEncoding(editor)) {
        header += '<meta http-equiv="Content-Type" content="text/html; charset=' + value + '" />\n';
      }
      if (value = getDefaultFontFamily(editor)) {
        styles += 'font-family: ' + value + ';';
      }
      if (value = getDefaultFontSize(editor)) {
        styles += 'font-size: ' + value + ';';
      }
      if (value = getDefaultTextColor(editor)) {
        styles += 'color: ' + value + ';';
      }
      header += '</head>\n<body' + (styles ? ' style="' + styles + '"' : '') + '>\n';
      return header;
    };
    var handleGetContent = function (editor, head, foot, evt) {
      if (evt.format === 'html' && !evt.selection && (!evt.source_view || !shouldHideInSourceView(editor))) {
        evt.content = unprotectHtml(pluginGlobal$3.trim(head) + '\n' + pluginGlobal$3.trim(evt.content) + '\n' + pluginGlobal$3.trim(foot));
      }
    };
    var setup = function (editor, headState, footState) {
      editor.on('BeforeSetContent', function (evt) {
        handleSetContent(editor, headState, footState, evt);
      });
      editor.on('GetContent', function (evt) {
        handleGetContent(editor, headState.get(), footState.get(), evt);
      });
    };

    var pluginRegister = function (editor) {
      editor.ui.registry.addButton('fullpage', {
        tooltip: 'Metadata and document properties',
        icon: 'document-properties',
        onAction: function () {
          editor.execCommand('mceFullPageProperties');
        }
      });
      editor.ui.registry.addMenuItem('fullpage', {
        text: 'Metadata and document properties',
        icon: 'document-properties',
        onAction: function () {
          editor.execCommand('mceFullPageProperties');
        }
      });
    };

    /*function Plugin () {
      pluginGlobal$4.add('fullpage', function (editor) {
        var headState = Cell(''), footState = Cell('');
        pluginRegister$1(editor, headState);
        pluginRegister(editor);
        setup(editor, headState, footState);
      });
    }*/

	// ---------------------------------------------------

    var isBogusImage = function (img) {
		return isNonNullable(img.attr('data-mce-bogus'));
	  };
	  var isInternalImageSource = function (img) {
		return img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));
	  };
	  var isValidDataImg = function (img, settings) {
		if (settings.images_dataimg_filter) {
		  var imgElem_1 = new Image();
		  imgElem_1.src = img.attr('src');
		  each$j(img.attributes.map, function (value, key) {
			imgElem_1.setAttribute(key, value);
		  });
		  return settings.images_dataimg_filter(imgElem_1);
		} else {
		  return true;
		}
	  };
	  var registerBase64ImageFilter = function (parser, settings) {
		var blobCache = settings.blob_cache;
		var processImage = function (img) {
		  var inputSrc = img.attr('src');
		  if (isInternalImageSource(img) || isBogusImage(img)) {
			return;
		  }
		  parseDataUri$1(inputSrc).filter(function () {
			return isValidDataImg(img, settings);
		  }).bind(function (_a) {
			var type = _a.type, data = _a.data;
			return Optional.from(blobCache.getByData(data, type)).orThunk(function () {
			  return buildBlob(type, data).map(function (blob) {
				var blobInfo = blobCache.create(uniqueId(), blob, data);
				blobCache.add(blobInfo);
				return blobInfo;
			  });
			});
		  }).each(function (blobInfo) {
			img.attr('src', blobInfo.blobUri());
		  });
		};
		if (blobCache) {
		  parser.addAttributeFilter('src', function (nodes) {
			return each$k(nodes, processImage);
		  });
		}
	  };
	  var register$1 = function (parser, settings) {
		var schema = parser.schema;
		if (settings.remove_trailing_brs) {
		  parser.addNodeFilter('br', function (nodes, _, args) {
			var i;
			var l = nodes.length;
			var node;
			var blockElements = Tools.extend({}, schema.getBlockElements());
			var nonEmptyElements = schema.getNonEmptyElements();
			var parent, lastParent, prev, prevName;
			var whiteSpaceElements = schema.getWhiteSpaceElements();
			var elementRule, textNode;
			blockElements.body = 1;
			for (i = 0; i < l; i++) {
			  node = nodes[i];
			  parent = node.parent;
			  if (blockElements[node.parent.name] && node === parent.lastChild) {
				prev = node.prev;
				while (prev) {
				  prevName = prev.name;
				  if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {
					if (prevName === 'br') {
					  node = null;
					}
					break;
				  }
				  prev = prev.prev;
				}
				if (node) {
				  node.remove();
				  if (isEmpty(schema, nonEmptyElements, whiteSpaceElements, parent)) {
					elementRule = schema.getElementRule(parent.name);
					if (elementRule) {
					  if (elementRule.removeEmpty) {
						parent.remove();
					  } else if (elementRule.paddEmpty) {
						paddEmptyNode(settings, args, blockElements, parent);
					  }
					}
				  }
				}
			  } else {
				lastParent = node;
				while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {
				  lastParent = parent;
				  if (blockElements[parent.name]) {
					break;
				  }
				  parent = parent.parent;
				}
				if (lastParent === parent && settings.padd_empty_with_br !== true) {
				  textNode = new AstNode('#text', 3);
				  textNode.value = nbsp;
				  node.replace(textNode);
				}
			  }
			}
		  });
		}
		parser.addAttributeFilter('href', function (nodes) {
		  var i = nodes.length;
		  var appendRel = function (rel) {
			var parts = rel.split(' ').filter(function (p) {
			  return p.length > 0;
			});
			return parts.concat(['noopener']).sort().join(' ');
		  };
		  var addNoOpener = function (rel) {
			var newRel = rel ? Tools.trim(rel) : '';
			if (!/\b(noopener)\b/g.test(newRel)) {
			  return appendRel(newRel);
			} else {
			  return newRel;
			}
		  };
		  if (!settings.allow_unsafe_link_target) {
			while (i--) {
			  var node = nodes[i];
			  if (node.name === 'a' && node.attr('target') === '_blank') {
				node.attr('rel', addNoOpener(node.attr('rel')));
			  }
			}
		  }
		});
		if (!settings.allow_html_in_named_anchor) {
		  parser.addAttributeFilter('id,name', function (nodes) {
			var i = nodes.length, sibling, prevSibling, parent, node;
			while (i--) {
			  node = nodes[i];
			  if (node.name === 'a' && node.firstChild && !node.attr('href')) {
				parent = node.parent;
				sibling = node.lastChild;
				do {
				  prevSibling = sibling.prev;
				  parent.insert(sibling, node);
				  sibling = prevSibling;
				} while (sibling);
			  }
			}
		  });
		}
		if (settings.fix_list_elements) {
		  parser.addNodeFilter('ul,ol', function (nodes) {
			var i = nodes.length, node, parentNode;
			while (i--) {
			  node = nodes[i];
			  parentNode = node.parent;
			  if (parentNode.name === 'ul' || parentNode.name === 'ol') {
				if (node.prev && node.prev.name === 'li') {
				  node.prev.append(node);
				} else {
				  var li = new AstNode('li', 1);
				  li.attr('style', 'list-style-type: none');
				  node.wrap(li);
				}
			  }
			}
		  });
		}
		if (settings.validate && schema.getValidClasses()) {
		  parser.addAttributeFilter('class', function (nodes) {
			var validClasses = schema.getValidClasses();
			var i = nodes.length;
			while (i--) {
			  var node = nodes[i];
			  var classList = node.attr('class').split(' ');
			  var classValue = '';
			  for (var ci = 0; ci < classList.length; ci++) {
				var className = classList[ci];
				var valid = false;
				var validClassesMap = validClasses['*'];
				if (validClassesMap && validClassesMap[className]) {
				  valid = true;
				}
				validClassesMap = validClasses[node.name];
				if (!valid && validClassesMap && validClassesMap[className]) {
				  valid = true;
				}
				if (valid) {
				  if (classValue) {
					classValue += ' ';
				  }
				  classValue += className;
				}
			  }
			  if (!classValue.length) {
				classValue = null;
			  }
			  node.attr('class', classValue);
			}
		  });
		}
		registerBase64ImageFilter(parser, settings);
	  };

	  var removeAttrs = function (node, names) {
		each$k(names, function (name) {
		  node.attr(name, null);
		});
	  };
	  var addFontToSpansFilter = function (domParser, styles, fontSizes) {
		domParser.addNodeFilter('font', function (nodes) {
		  each$k(nodes, function (node) {
			var props = styles.parse(node.attr('style'));
			var color = node.attr('color');
			var face = node.attr('face');
			var size = node.attr('size');
			if (color) {
			  props.color = color;
			}
			if (face) {
			  props['font-family'] = face;
			}
			if (size) {
			  props['font-size'] = fontSizes[parseInt(node.attr('size'), 10) - 1];
			}
			node.name = 'span';
			node.attr('style', styles.serialize(props));
			removeAttrs(node, [
			  'color',
			  'face',
			  'size'
			]);
		  });
		});
	  };
	  var addStrikeToSpanFilter = function (domParser, styles) {
		domParser.addNodeFilter('strike', function (nodes) {
		  each$k(nodes, function (node) {
			var props = styles.parse(node.attr('style'));
			props['text-decoration'] = 'line-through';
			node.name = 'span';
			node.attr('style', styles.serialize(props));
		  });
		});
	  };
	  var addFilters = function (domParser, settings) {
		var styles = Styles();
		if (settings.convert_fonts_to_spans) {
		  addFontToSpansFilter(domParser, styles, Tools.explode(settings.font_size_legacy_values));
		}
		addStrikeToSpanFilter(domParser, styles);
	  };
	  var register$2 = function (domParser, settings) {
		if (settings.inline_styles) {
		  addFilters(domParser, settings);
		}
	  };


      var addAttributeFilter = function (name, callback) {
        each$6(explode$2(name), function (name) {
          var i;
          for (i = 0; i < attributeFilters.length; i++) {
            if (attributeFilters[i].name === name) {
              attributeFilters[i].callbacks.push(callback);
              return;
            }
          }
          attributeFilters.push({
            name: name,
            callbacks: [callback]
          });
        });
      };

	  var createParser = function (editor) {
		var parser = DomParser(mkParserSettings(editor), editor.schema);
		parser.addAttributeFilter('src,href,style,tabindex', function (nodes, name) {
		  var i = nodes.length, node, value;
		  var dom = editor.dom;
		  var internalName = 'data-mce-' + name;
		  while (i--) {
			node = nodes[i];
			value = node.attr(name);
			if (value && !node.attr(internalName)) {
			  if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {
				continue;
			  }
			  if (name === 'style') {
				value = dom.serializeStyle(dom.parseStyle(value), node.name);
				if (!value.length) {
				  value = null;
				}
				node.attr(internalName, value);
				node.attr(name, value);
			  } else if (name === 'tabindex') {
				node.attr(internalName, value);
				node.attr(name, null);
			  } else {
				node.attr(internalName, editor.convertURL(value, name, node.name));
			  }
			}
		  }
		});
		parser.addNodeFilter('script', function (nodes) {
		  var i = nodes.length;
		  while (i--) {
			var node = nodes[i];
			var type = node.attr('type') || 'no/type';
			if (type.indexOf('mce-') !== 0) {
			  node.attr('type', 'mce-' + type);
			}
		  }
		});
		if (editor.settings.preserve_cdata) {
		  parser.addNodeFilter('#cdata', function (nodes) {
			var i = nodes.length;
			while (i--) {
			  var node = nodes[i];
			  node.type = 8;
			  node.name = '#comment';
			  node.value = '[CDATA[' + editor.dom.encode(node.value) + ']]';
			}
		  });
		}
		parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', function (nodes) {
		  var i = nodes.length;
		  var nonEmptyElements = editor.schema.getNonEmptyElements();
		  while (i--) {
			var node = nodes[i];
			if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {
			  node.append(new AstNode('br', 1)).shortEnded = true;
			}
		  }
		});
		return parser;
	  };

	  var Schema = function (settings) {
		var elements = {};
		var children = {};
		var patternElements = [];
		var customElementsMap = {}, specialElements = {};
		var createLookupTable = function (option, defaultValue, extendWith) {
		  var value = settings[option];
		  if (!value) {
			value = mapCache[option];
			if (!value) {
			  value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));
			  value = extend$5(value, extendWith);
			  mapCache[option] = value;
			}
		  } else {
			value = makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));
		  }
		  return value;
		};
		settings = settings || {};
		var schemaItems = compileSchema(settings.schema);
		if (settings.verify_html === false) {
		  settings.valid_elements = '*[*]';
		}
		var validStyles = compileElementMap(settings.valid_styles);
		var invalidStyles = compileElementMap(settings.invalid_styles, 'map');
		var validClasses = compileElementMap(settings.valid_classes, 'map');
		var whiteSpaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');
		var selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');
		var shortEndedElementsMap = createLookupTable('short_ended_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');
		var boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls');
		var nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';
		var nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre', shortEndedElementsMap);
		var moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', shortEndedElementsMap);
		var textBlockElementsMap = createLookupTable('text_block_elements', 'h1 h2 h3 h4 h5 h6 p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');
		var blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary', textBlockElementsMap);
		var textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font strike u var cite ' + 'dfn code mark q sup sub samp');
		each$h((settings.special || 'script noscript iframe noframes noembed title style textarea xmp').split(' '), function (name) {
		  specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');
		});
		var patternToRegExp = function (str) {
		  return new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');
		};
		var addValidElements = function (validElements) {
		  var ei, el, ai, al, matches, element, attr, attrData, elementName, attrName, attrType, attributes, attributesOrder, prefix, outputName, globalAttributes, globalAttributesOrder, value;
		  var elementRuleRegExp = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/, attrRuleRegExp = /^([!\-])?(\w+[\\:]:\w+|[^=:<]+)?(?:([=:<])(.*))?$/, hasPatternsRegExp = /[*?+]/;
		  if (validElements) {
			var validElementsArr = split$1(validElements, ',');
			if (elements['@']) {
			  globalAttributes = elements['@'].attributes;
			  globalAttributesOrder = elements['@'].attributesOrder;
			}
			for (ei = 0, el = validElementsArr.length; ei < el; ei++) {
			  matches = elementRuleRegExp.exec(validElementsArr[ei]);
			  if (matches) {
				prefix = matches[1];
				elementName = matches[2];
				outputName = matches[3];
				attrData = matches[5];
				attributes = {};
				attributesOrder = [];
				element = {
				  attributes: attributes,
				  attributesOrder: attributesOrder
				};
				if (prefix === '#') {
				  element.paddEmpty = true;
				}
				if (prefix === '-') {
				  element.removeEmpty = true;
				}
				if (matches[4] === '!') {
				  element.removeEmptyAttrs = true;
				}
				if (globalAttributes) {
				  each$j(globalAttributes, function (value, key) {
					attributes[key] = value;
				  });
				  attributesOrder.push.apply(attributesOrder, globalAttributesOrder);
				}
				if (attrData) {
				  attrData = split$1(attrData, '|');
				  for (ai = 0, al = attrData.length; ai < al; ai++) {
					matches = attrRuleRegExp.exec(attrData[ai]);
					if (matches) {
					  attr = {};
					  attrType = matches[1];
					  attrName = matches[2].replace(/[\\:]:/g, ':');
					  prefix = matches[3];
					  value = matches[4];
					  if (attrType === '!') {
						element.attributesRequired = element.attributesRequired || [];
						element.attributesRequired.push(attrName);
						attr.required = true;
					  }
					  if (attrType === '-') {
						delete attributes[attrName];
						attributesOrder.splice(inArray$2(attributesOrder, attrName), 1);
						continue;
					  }
					  if (prefix) {
						if (prefix === '=') {
						  element.attributesDefault = element.attributesDefault || [];
						  element.attributesDefault.push({
							name: attrName,
							value: value
						  });
						  attr.defaultValue = value;
						}
						if (prefix === ':') {
						  element.attributesForced = element.attributesForced || [];
						  element.attributesForced.push({
							name: attrName,
							value: value
						  });
						  attr.forcedValue = value;
						}
						if (prefix === '<') {
						  attr.validValues = makeMap$2(value, '?');
						}
					  }
					  if (hasPatternsRegExp.test(attrName)) {
						element.attributePatterns = element.attributePatterns || [];
						attr.pattern = patternToRegExp(attrName);
						element.attributePatterns.push(attr);
					  } else {
						if (!attributes[attrName]) {
						  attributesOrder.push(attrName);
						}
						attributes[attrName] = attr;
					  }
					}
				  }
				}
				if (!globalAttributes && elementName === '@') {
				  globalAttributes = attributes;
				  globalAttributesOrder = attributesOrder;
				}
				if (outputName) {
				  element.outputName = elementName;
				  elements[outputName] = element;
				}
				if (hasPatternsRegExp.test(elementName)) {
				  element.pattern = patternToRegExp(elementName);
				  patternElements.push(element);
				} else {
				  elements[elementName] = element;
				}
			  }
			}
		  }
		};
		var setValidElements = function (validElements) {
		  elements = {};
		  patternElements = [];
		  addValidElements(validElements);
		  each$h(schemaItems, function (element, name) {
			children[name] = element.children;
		  });
		};
		var addCustomElements = function (customElements) {
		  var customElementRegExp = /^(~)?(.+)$/;
		  if (customElements) {
			mapCache.text_block_elements = mapCache.block_elements = null;
			each$h(split$1(customElements, ','), function (rule) {
			  var matches = customElementRegExp.exec(rule), inline = matches[1] === '~', cloneName = inline ? 'span' : 'div', name = matches[2];
			  children[name] = children[cloneName];
			  customElementsMap[name] = cloneName;
			  if (!inline) {
				blockElementsMap[name.toUpperCase()] = {};
				blockElementsMap[name] = {};
			  }
			  if (!elements[name]) {
				var customRule = elements[cloneName];
				customRule = extend$5({}, customRule);
				delete customRule.removeEmptyAttrs;
				delete customRule.removeEmpty;
				elements[name] = customRule;
			  }
			  each$h(children, function (element, elmName) {
				if (element[cloneName]) {
				  children[elmName] = element = extend$5({}, children[elmName]);
				  element[name] = element[cloneName];
				}
			  });
			});
		  }
		};
		var addValidChildren = function (validChildren) {
		  var childRuleRegExp = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
		  mapCache[settings.schema] = null;
		  if (validChildren) {
			each$h(split$1(validChildren, ','), function (rule) {
			  var matches = childRuleRegExp.exec(rule);
			  var parent, prefix;
			  if (matches) {
				prefix = matches[1];
				if (prefix) {
				  parent = children[matches[2]];
				} else {
				  parent = children[matches[2]] = { '#comment': {} };
				}
				parent = children[matches[2]];
				each$h(split$1(matches[3], '|'), function (child) {
				  if (prefix === '-') {
					delete parent[child];
				  } else {
					parent[child] = {};
				  }
				});
			  }
			});
		  }
		};
		var getElementRule = function (name) {
		  var element = elements[name], i;
		  if (element) {
			return element;
		  }
		  i = patternElements.length;
		  while (i--) {
			element = patternElements[i];
			if (element.pattern.test(name)) {
			  return element;
			}
		  }
		};
		if (!settings.valid_elements) {
		  each$h(schemaItems, function (element, name) {
			elements[name] = {
			  attributes: element.attributes,
			  attributesOrder: element.attributesOrder
			};
			children[name] = element.children;
		  });
		  if (settings.schema !== 'html5') {
			each$h(split$1('strong/b em/i'), function (item) {
			  var items = split$1(item, '/');
			  elements[items[1]].outputName = items[0];
			});
		  }
		  each$h(split$1('ol ul sub sup blockquote span font a table tbody strong em b i'), function (name) {
			if (elements[name]) {
			  elements[name].removeEmpty = true;
			}
		  });
		  each$h(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li'), function (name) {
			elements[name].paddEmpty = true;
		  });
		  each$h(split$1('span'), function (name) {
			elements[name].removeEmptyAttrs = true;
		  });
		} else {
		  setValidElements(settings.valid_elements);
		}
		addCustomElements(settings.custom_elements);
		addValidChildren(settings.valid_children);
		addValidElements(settings.extended_valid_elements);
		addValidChildren('+ol[ul|ol],+ul[ul|ol]');
		each$h({
		  dd: 'dl',
		  dt: 'dl',
		  li: 'ul ol',
		  td: 'tr',
		  th: 'tr',
		  tr: 'tbody thead tfoot',
		  tbody: 'table',
		  thead: 'table',
		  tfoot: 'table',
		  legend: 'fieldset',
		  area: 'map',
		  param: 'video audio object'
		}, function (parents, item) {
		  if (elements[item]) {
			elements[item].parentsRequired = split$1(parents);
		  }
		});
		if (settings.invalid_elements) {
		  each$h(explode$3(settings.invalid_elements), function (item) {
			if (elements[item]) {
			  delete elements[item];
			}
		  });
		}
		if (!getElementRule('span')) {
		  addValidElements('span[!data-mce-type|*]');
		}
		var getValidStyles = constant(validStyles);
		var getInvalidStyles = constant(invalidStyles);
		var getValidClasses = constant(validClasses);
		var getBoolAttrs = constant(boolAttrMap);
		var getBlockElements = constant(blockElementsMap);
		var getTextBlockElements = constant(textBlockElementsMap);
		var getTextInlineElements = constant(textInlineElementsMap);
		var getShortEndedElements = constant(shortEndedElementsMap);
		var getSelfClosingElements = constant(selfClosingElementsMap);
		var getNonEmptyElements = constant(nonEmptyElementsMap);
		var getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);
		var getWhiteSpaceElements = constant(whiteSpaceElementsMap);
		var getSpecialElements = constant(specialElements);
		var isValidChild = function (name, child) {
		  var parent = children[name.toLowerCase()];
		  return !!(parent && parent[child.toLowerCase()]);
		};
		var isValid = function (name, attr) {
		  var attrPatterns, i;
		  var rule = getElementRule(name);
		  if (rule) {
			if (attr) {
			  if (rule.attributes[attr]) {
				return true;
			  }
			  attrPatterns = rule.attributePatterns;
			  if (attrPatterns) {
				i = attrPatterns.length;
				while (i--) {
				  if (attrPatterns[i].pattern.test(name)) {
					return true;
				  }
				}
			  }
			} else {
			  return true;
			}
		  }
		  return false;
		};
		var getCustomElements = constant(customElementsMap);
		return {
		  children: children,
		  elements: elements,
		  getValidStyles: getValidStyles,
		  getValidClasses: getValidClasses,
		  getBlockElements: getBlockElements,
		  getInvalidStyles: getInvalidStyles,
		  getShortEndedElements: getShortEndedElements,
		  getTextBlockElements: getTextBlockElements,
		  getTextInlineElements: getTextInlineElements,
		  getBoolAttrs: getBoolAttrs,
		  getElementRule: getElementRule,
		  getSelfClosingElements: getSelfClosingElements,
		  getNonEmptyElements: getNonEmptyElements,
		  getMoveCaretBeforeOnEnterElements: getMoveCaretBeforeOnEnterElements,
		  getWhiteSpaceElements: getWhiteSpaceElements,
		  getSpecialElements: getSpecialElements,
		  isValidChild: isValidChild,
		  isValid: isValid,
		  getCustomElements: getCustomElements,
		  addValidElements: addValidElements,
		  setValidElements: setValidElements,
		  addCustomElements: addCustomElements,
		  addValidChildren: addValidChildren
		};
	  };

	  var constant = function (value) {
		return function () {
		  return value;
		};
	  };

	  var keys = Object.keys;
	  var hasOwnProperty$1 = Object.hasOwnProperty;
	  var each$j = function (obj, f) {
		var props = keys(obj);
		for (var k = 0, len = props.length; k < len; k++) {
		  var i = props[k];
		  var x = obj[i];
		  f(x, i);
		}
	  };
	  var map$2 = function (obj, f) {
		return tupleMap(obj, function (x, i) {
		  return {
			k: i,
			v: f(x, i)
		  };
		});
	  };
	  var tupleMap = function (obj, f) {
		var r = {};
		each$j(obj, function (x, i) {
		  var tuple = f(x, i);
		  r[tuple.k] = tuple.v;
		});
		return r;
	  };
	  var objAcc = function (r) {
		return function (x, i) {
		  r[i] = x;
		};
	  };
	  var internalFilter = function (obj, pred, onTrue, onFalse) {
		var r = {};
		each$j(obj, function (x, i) {
		  (pred(x, i) ? onTrue : onFalse)(x, i);
		});
		return r;
	  };
	  var bifilter = function (obj, pred) {
		var t = {};
		var f = {};
		internalFilter(obj, pred, objAcc(t), objAcc(f));
		return {
		  t: t,
		  f: f
		};
	  };
	  var filter$3 = function (obj, pred) {
		var t = {};
		internalFilter(obj, pred, objAcc(t), noop);
		return t;
	  };
	  var mapToArray = function (obj, f) {
		var r = [];
		each$j(obj, function (value, name) {
		  r.push(f(value, name));
		});
		return r;
	  };
	  var values = function (obj) {
		return mapToArray(obj, identity);
	  };
	  var get$9 = function (obj, key) {
		return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();
	  };
	  var has$2 = function (obj, key) {
		return hasOwnProperty$1.call(obj, key);
	  };
	  var hasNonNullableKey = function (obj, key) {
		return has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;
	  };
	  var equal$1 = function (a1, a2, eq) {
		if (eq === void 0) {
		  eq = eqAny;
		}
		return eqRecord(eq).eq(a1, a2);
	  };

	  var isArray = Array.isArray;
	  var toArray$1 = function (obj) {
		if (!isArray(obj)) {
		  var array = [];
		  for (var i = 0, l = obj.length; i < l; i++) {
			array[i] = obj[i];
		  }
		  return array;
		} else {
		  return obj;
		}
	  };
	  var each$i = function (o, cb, s) {
		var n, l;
		if (!o) {
		  return false;
		}
		s = s || o;
		if (o.length !== undefined) {
		  for (n = 0, l = o.length; n < l; n++) {
			if (cb.call(s, o[n], n, o) === false) {
			  return false;
			}
		  }
		} else {
		  for (n in o) {
			if (has$2(o, n)) {
			  if (cb.call(s, o[n], n, o) === false) {
				return false;
			  }
			}
		  }
		}
		return true;
	  };
	  var map$1 = function (array, callback) {
		var out = [];
		each$i(array, function (item, index) {
		  out.push(callback(item, index, array));
		});
		return out;
	  };
	  var filter$2 = function (a, f) {
		var o = [];
		each$i(a, function (v, index) {
		  if (!f || f(v, index, a)) {
			o.push(v);
		  }
		});
		return o;
	  };
	  var indexOf$1 = function (a, v) {
		if (a) {
		  for (var i = 0, l = a.length; i < l; i++) {
			if (a[i] === v) {
			  return i;
			}
		  }
		}
		return -1;
	  };
	  var reduce = function (collection, iteratee, accumulator, thisArg) {
		var acc = isUndefined(accumulator) ? collection[0] : accumulator;
		for (var i = 0; i < collection.length; i++) {
		  acc = iteratee.call(thisArg, acc, collection[i], i);
		}
		return acc;
	  };
	  var findIndex$1 = function (array, predicate, thisArg) {
		var i, l;
		for (i = 0, l = array.length; i < l; i++) {
		  if (predicate.call(thisArg, array[i], i, array)) {
			return i;
		  }
		}
		return -1;
	  };
	  var last$1 = function (collection) {
		return collection[collection.length - 1];
	  };

	  var mapCache = {}, dummyObj = {};
	  var makeMap$2 = Tools.makeMap, each$h = Tools.each, extend$5 = Tools.extend, explode$3 = Tools.explode, inArray$2 = Tools.inArray;
	  var split$1 = function (items, delim) {
		items = Tools.trim(items);
		return items ? items.split(delim || ' ') : [];
	  };
	  var compileSchema = function (type) {
		var schema = {};
		var globalAttributes, blockContent;
		var phrasingContent, flowContent, html4BlockContent, html4PhrasingContent;
		var add = function (name, attributes, children) {
		  var ni, attributesOrder, element;
		  var arrayToMap = function (array, obj) {
			var map = {};
			var i, l;
			for (i = 0, l = array.length; i < l; i++) {
			  map[array[i]] = obj || {};
			}
			return map;
		  };
		  children = children || [];
		  attributes = attributes || '';
		  if (typeof children === 'string') {
			children = split$1(children);
		  }
		  var names = split$1(name);
		  ni = names.length;
		  while (ni--) {
			attributesOrder = split$1([
			  globalAttributes,
			  attributes
			].join(' '));
			element = {
			  attributes: arrayToMap(attributesOrder),
			  attributesOrder: attributesOrder,
			  children: arrayToMap(children, dummyObj)
			};
			schema[names[ni]] = element;
		  }
		};
		var addAttrs = function (name, attributes) {
		  var ni, schemaItem, i, l;
		  var names = split$1(name);
		  ni = names.length;
		  var attrs = split$1(attributes);
		  while (ni--) {
			schemaItem = schema[names[ni]];
			for (i = 0, l = attrs.length; i < l; i++) {
			  schemaItem.attributes[attrs[i]] = {};
			  schemaItem.attributesOrder.push(attrs[i]);
			}
		  }
		};
		if (mapCache[type]) {
		  return mapCache[type];
		}
		globalAttributes = 'id accesskey class dir lang style tabindex title role';
		blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';
		phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';
		if (type !== 'html4') {
		  globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';
		  blockContent += ' article aside details dialog figure main header footer hgroup section nav';
		  phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen';
		}
		if (type !== 'html5-strict') {
		  globalAttributes += ' xml:lang';
		  html4PhrasingContent = 'acronym applet basefont big font strike tt';
		  phrasingContent = [
			phrasingContent,
			html4PhrasingContent
		  ].join(' ');
		  each$h(split$1(html4PhrasingContent), function (name) {
			add(name, '', phrasingContent);
		  });
		  html4BlockContent = 'center dir isindex noframes';
		  blockContent = [
			blockContent,
			html4BlockContent
		  ].join(' ');
		  flowContent = [
			blockContent,
			phrasingContent
		  ].join(' ');
		  each$h(split$1(html4BlockContent), function (name) {
			add(name, '', flowContent);
		  });
		}
		flowContent = flowContent || [
		  blockContent,
		  phrasingContent
		].join(' ');
		add('html', 'manifest', 'head body');
		add('head', '', 'base command link meta noscript script style title');
		add('title hr noscript br');
		add('base', 'href target');
		add('link', 'href rel media hreflang type sizes hreflang');
		add('meta', 'name http-equiv content charset');
		add('style', 'media type scoped');
		add('script', 'src async defer type charset');
		add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);
		add('address dt dd div caption', '', flowContent);
		add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);
		add('blockquote', 'cite', flowContent);
		add('ol', 'reversed start type', 'li');
		add('ul', '', 'li');
		add('li', 'value', flowContent);
		add('dl', '', 'dt dd');
		add('a', 'href target rel media hreflang type', phrasingContent);
		add('q', 'cite', phrasingContent);
		add('ins del', 'cite datetime', flowContent);
		add('img', 'src sizes srcset alt usemap ismap width height');
		add('iframe', 'src name width height', flowContent);
		add('embed', 'src type width height');
		add('object', 'data type typemustmatch name usemap form width height', [
		  flowContent,
		  'param'
		].join(' '));
		add('param', 'name value');
		add('map', 'name', [
		  flowContent,
		  'area'
		].join(' '));
		add('area', 'alt coords shape href target rel media hreflang type');
		add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));
		add('colgroup', 'span', 'col');
		add('col', 'span');
		add('tbody thead tfoot', '', 'tr');
		add('tr', '', 'td th');
		add('td', 'colspan rowspan headers', flowContent);
		add('th', 'colspan rowspan headers scope abbr', flowContent);
		add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);
		add('fieldset', 'disabled form name', [
		  flowContent,
		  'legend'
		].join(' '));
		add('label', 'form for', phrasingContent);
		add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');
		add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);
		add('select', 'disabled form multiple name required size', 'option optgroup');
		add('optgroup', 'disabled label', 'option');
		add('option', 'disabled label selected value');
		add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');
		add('menu', 'type label', [
		  flowContent,
		  'li'
		].join(' '));
		add('noscript', '', flowContent);
		if (type !== 'html4') {
		  add('wbr');
		  add('ruby', '', [
			phrasingContent,
			'rt rp'
		  ].join(' '));
		  add('figcaption', '', flowContent);
		  add('mark rt rp summary bdi', '', phrasingContent);
		  add('canvas', 'width height', flowContent);
		  add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [
			flowContent,
			'track source'
		  ].join(' '));
		  add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [
			flowContent,
			'track source'
		  ].join(' '));
		  add('picture', '', 'img source');
		  add('source', 'src srcset type media sizes');
		  add('track', 'kind src srclang label default');
		  add('datalist', '', [
			phrasingContent,
			'option'
		  ].join(' '));
		  add('article section nav aside main header footer', '', flowContent);
		  add('hgroup', '', 'h1 h2 h3 h4 h5 h6');
		  add('figure', '', [
			flowContent,
			'figcaption'
		  ].join(' '));
		  add('time', 'datetime', phrasingContent);
		  add('dialog', 'open', flowContent);
		  add('command', 'type label icon disabled checked radiogroup command');
		  add('output', 'for form name', phrasingContent);
		  add('progress', 'value max', phrasingContent);
		  add('meter', 'value min max low high optimum', phrasingContent);
		  add('details', 'open', [
			flowContent,
			'summary'
		  ].join(' '));
		  add('keygen', 'autofocus challenge disabled form keytype name');
		}
		if (type !== 'html5-strict') {
		  addAttrs('script', 'language xml:space');
		  addAttrs('style', 'xml:space');
		  addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');
		  addAttrs('embed', 'align name hspace vspace');
		  addAttrs('param', 'valuetype type');
		  addAttrs('a', 'charset name rev shape coords');
		  addAttrs('br', 'clear');
		  addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');
		  addAttrs('img', 'name longdesc align border hspace vspace');
		  addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');
		  addAttrs('font basefont', 'size color face');
		  addAttrs('input', 'usemap align');
		  addAttrs('select');
		  addAttrs('textarea');
		  addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');
		  addAttrs('ul', 'type compact');
		  addAttrs('li', 'type');
		  addAttrs('ol dl menu dir', 'compact');
		  addAttrs('pre', 'width xml:space');
		  addAttrs('hr', 'align noshade size width');
		  addAttrs('isindex', 'prompt');
		  addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');
		  addAttrs('col', 'width align char charoff valign');
		  addAttrs('colgroup', 'width align char charoff valign');
		  addAttrs('thead', 'align char charoff valign');
		  addAttrs('tr', 'align char charoff valign bgcolor');
		  addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');
		  addAttrs('form', 'accept');
		  addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');
		  addAttrs('tfoot', 'align char charoff valign');
		  addAttrs('tbody', 'align char charoff valign');
		  addAttrs('area', 'nohref');
		  addAttrs('body', 'background bgcolor text link vlink alink');
		}
		if (type !== 'html4') {
		  addAttrs('input button select textarea', 'autofocus');
		  addAttrs('input textarea', 'placeholder');
		  addAttrs('a', 'download');
		  addAttrs('link script img', 'crossorigin');
		  addAttrs('img', 'loading');
		  addAttrs('iframe', 'sandbox seamless allowfullscreen loading');
		}
		each$h(split$1('a form meter progress dfn'), function (name) {
		  if (schema[name]) {
			delete schema[name].children[name];
		  }
		});
		delete schema.caption.children.table;
		delete schema.script;
		mapCache[type] = schema;
		return schema;
	  };

	  var SaxParser = function (settings, schema) {
		var _a;
		if (schema === void 0) {
		  schema = Schema();
		}
		settings = settings || {};
		var doc = (_a = settings.document) !== null && _a !== void 0 ? _a : document;
		var form = doc.createElement('form');
		if (settings.fix_self_closing !== false) {
		  settings.fix_self_closing = true;
		}
		var comment = settings.comment ? settings.comment : noop;
		var cdata = settings.cdata ? settings.cdata : noop;
		var text = settings.text ? settings.text : noop;
		var start = settings.start ? settings.start : noop;
		var end = settings.end ? settings.end : noop;
		var pi = settings.pi ? settings.pi : noop;
		var doctype = settings.doctype ? settings.doctype : noop;
		var parseInternal = function (base64Extract, format) {
		  if (format === void 0) {
			format = 'html';
		  }
		  var html = base64Extract.html;
		  var matches, index = 0, value, endRegExp;
		  var stack = [];
		  var attrList, i, textData, name;
		  var isInternalElement, isShortEnded;
		  var elementRule, isValidElement, attr, attribsValue, validAttributesMap, validAttributePatterns;
		  var attributesRequired, attributesDefault, attributesForced;
		  var anyAttributesRequired, attrValue, idCount = 0;
		  var decode = Entities.decode;
		  var filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');
		  var parsingMode = format === 'html' ? 0 : 1;
		  var processEndTag = function (name) {
			var pos, i;
			pos = stack.length;
			while (pos--) {
			  if (stack[pos].name === name) {
				break;
			  }
			}
			if (pos >= 0) {
			  for (i = stack.length - 1; i >= pos; i--) {
				name = stack[i];
				if (name.valid) {
				  end(name.name);
				}
			  }
			  stack.length = pos;
			}
		  };
		  var processText = function (value, raw) {
			return text(restoreDataUris(value, base64Extract), raw);
		  };
		  var processComment = function (value) {
			if (value === '') {
			  return;
			}
			if (value.charAt(0) === '>') {
			  value = ' ' + value;
			}
			if (!settings.allow_conditional_comments && value.substr(0, 3).toLowerCase() === '[if') {
			  value = ' ' + value;
			}
			comment(restoreDataUris(value, base64Extract));
		  };
		  var processAttr = function (value) {
			return restoreDataUris(value, base64Extract);
		  };
		  var processMalformedComment = function (value, startIndex) {
			var startTag = value || '';
			var isBogus = !startsWith(startTag, '--');
			var endIndex = findCommentEndIndex(html, isBogus, startIndex);
			value = html.substr(startIndex, endIndex - startIndex);
			processComment(isBogus ? startTag + value : value);
			return endIndex + 1;
		  };
		  var parseAttribute = function (tagName, name, value, val2, val3) {
			name = name.toLowerCase();
			value = processAttr(name in fillAttrsMap ? name : decode(value || val2 || val3 || ''));
			if (validate && !isInternalElement && isValidPrefixAttrName(name) === false) {
			  var attrRule = validAttributesMap[name];
			  if (!attrRule && validAttributePatterns) {
				var i_1 = validAttributePatterns.length;
				while (i_1--) {
				  attrRule = validAttributePatterns[i_1];
				  if (attrRule.pattern.test(name)) {
					break;
				  }
				}
				if (i_1 === -1) {
				  attrRule = null;
				}
			  }
			  if (!attrRule) {
				return;
			  }
			  if (attrRule.validValues && !(value in attrRule.validValues)) {
				return;
			  }
			}
			var isNameOrId = name === 'name' || name === 'id';
			if (isNameOrId && tagName in filteredClobberElements && (value in doc || value in form)) {
			  return;
			}
			if (filteredUrlAttrs[name] && !URI.isDomSafe(value, tagName, settings)) {
			  return;
			}
			if (isInternalElement && (name in filteredUrlAttrs || name.indexOf('on') === 0)) {
			  return;
			}
			attrList.map[name] = value;
			attrList.push({
			  name: name,
			  value: value
			});
		  };
		  var tokenRegExp = new RegExp('<(?:' + '(?:!--([\\w\\W]*?)--!?>)|' + '(?:!\\[CDATA\\[([\\w\\W]*?)\\]\\]>)|' + '(?:![Dd][Oo][Cc][Tt][Yy][Pp][Ee]([\\w\\W]*?)>)|' + '(?:!(--)?)|' + '(?:\\?([^\\s\\/<>]+) ?([\\w\\W]*?)[?/]>)|' + '(?:\\/([A-Za-z][A-Za-z0-9\\-_\\:\\.]*)>)|' + '(?:([A-Za-z][A-Za-z0-9\\-_:.]*)(\\s(?:[^\'">]+(?:"[^"]*"|\'[^\']*\'))*[^"\'>]*(?:"[^">]*|\'[^\'>]*)?|\\s*|\\/)>)' + ')', 'g');
		  var attrRegExp = /([\w:\-]+)(?:\s*=\s*(?:(?:\"((?:[^\"])*)\")|(?:\'((?:[^\'])*)\')|([^>\s]+)))?/g;
		  var shortEndedElements = schema.getShortEndedElements();
		  var selfClosing = settings.self_closing_elements || schema.getSelfClosingElements();
		  var fillAttrsMap = schema.getBoolAttrs();
		  var validate = settings.validate;
		  var removeInternalElements = settings.remove_internals;
		  var fixSelfClosing = settings.fix_self_closing;
		  var specialElements = schema.getSpecialElements();
		  var processHtml = html + '>';
		  while (matches = tokenRegExp.exec(processHtml)) {
			var matchText = matches[0];
			if (index < matches.index) {
			  processText(decode(html.substr(index, matches.index - index)));
			}
			if (value = matches[7]) {
			  value = value.toLowerCase();
			  if (value.charAt(0) === ':') {
				value = value.substr(1);
			  }
			  processEndTag(value);
			} else if (value = matches[8]) {
			  if (matches.index + matchText.length > html.length) {
				processText(decode(html.substr(matches.index)));
				index = matches.index + matchText.length;
				continue;
			  }
			  value = value.toLowerCase();
			  if (value.charAt(0) === ':') {
				value = value.substr(1);
			  }
			  isShortEnded = value in shortEndedElements;
			  if (fixSelfClosing && selfClosing[value] && stack.length > 0 && stack[stack.length - 1].name === value) {
				processEndTag(value);
			  }
			  var bogusValue = checkBogusAttribute(attrRegExp, matches[9]);
			  if (bogusValue !== null) {
				if (bogusValue === 'all') {
				  index = findMatchingEndTagIndex(schema, html, tokenRegExp.lastIndex);
				  tokenRegExp.lastIndex = index;
				  continue;
				}
				isValidElement = false;
			  }
			  if (!validate || (elementRule = schema.getElementRule(value))) {
				isValidElement = true;
				if (validate) {
				  validAttributesMap = elementRule.attributes;
				  validAttributePatterns = elementRule.attributePatterns;
				}
				if (attribsValue = matches[9]) {
				  isInternalElement = attribsValue.indexOf('data-mce-type') !== -1;
				  if (isInternalElement && removeInternalElements) {
					isValidElement = false;
				  }
				  attrList = [];
				  attrList.map = {};
				  attribsValue.replace(attrRegExp, function (match, name, val, val2, val3) {
					parseAttribute(value, name, val, val2, val3);
					return '';
				  });
				} else {
				  attrList = [];
				  attrList.map = {};
				}
				if (validate && !isInternalElement) {
				  attributesRequired = elementRule.attributesRequired;
				  attributesDefault = elementRule.attributesDefault;
				  attributesForced = elementRule.attributesForced;
				  anyAttributesRequired = elementRule.removeEmptyAttrs;
				  if (anyAttributesRequired && !attrList.length) {
					isValidElement = false;
				  }
				  if (attributesForced) {
					i = attributesForced.length;
					while (i--) {
					  attr = attributesForced[i];
					  name = attr.name;
					  attrValue = attr.value;
					  if (attrValue === '{$uid}') {
						attrValue = 'mce_' + idCount++;
					  }
					  attrList.map[name] = attrValue;
					  attrList.push({
						name: name,
						value: attrValue
					  });
					}
				  }
				  if (attributesDefault) {
					i = attributesDefault.length;
					while (i--) {
					  attr = attributesDefault[i];
					  name = attr.name;
					  if (!(name in attrList.map)) {
						attrValue = attr.value;
						if (attrValue === '{$uid}') {
						  attrValue = 'mce_' + idCount++;
						}
						attrList.map[name] = attrValue;
						attrList.push({
						  name: name,
						  value: attrValue
						});
					  }
					}
				  }
				  if (attributesRequired) {
					i = attributesRequired.length;
					while (i--) {
					  if (attributesRequired[i] in attrList.map) {
						break;
					  }
					}
					if (i === -1) {
					  isValidElement = false;
					}
				  }
				  if (attr = attrList.map['data-mce-bogus']) {
					if (attr === 'all') {
					  index = findMatchingEndTagIndex(schema, html, tokenRegExp.lastIndex);
					  tokenRegExp.lastIndex = index;
					  continue;
					}
					isValidElement = false;
				  }
				}
				if (isValidElement) {
				  start(value, attrList, isShortEnded);
				}
			  } else {
				isValidElement = false;
			  }
			  if (endRegExp = specialElements[value]) {
				endRegExp.lastIndex = index = matches.index + matchText.length;
				if (matches = endRegExp.exec(html)) {
				  if (isValidElement) {
					textData = html.substr(index, matches.index - index);
				  }
				  index = matches.index + matches[0].length;
				} else {
				  textData = html.substr(index);
				  index = html.length;
				}
				if (isValidElement) {
				  if (textData.length > 0) {
					processText(textData, true);
				  }
				  end(value);
				}
				tokenRegExp.lastIndex = index;
				continue;
			  }
			  if (!isShortEnded) {
				if (!attribsValue || attribsValue.indexOf('/') !== attribsValue.length - 1) {
				  stack.push({
					name: value,
					valid: isValidElement
				  });
				} else if (isValidElement) {
				  end(value);
				}
			  }
			} else if (value = matches[1]) {
			  processComment(value);
			} else if (value = matches[2]) {
			  var isValidCdataSection = parsingMode === 1 || settings.preserve_cdata || stack.length > 0 && schema.isValidChild(stack[stack.length - 1].name, '#cdata');
			  if (isValidCdataSection) {
				cdata(value);
			  } else {
				index = processMalformedComment('', matches.index + 2);
				tokenRegExp.lastIndex = index;
				continue;
			  }
			} else if (value = matches[3]) {
			  doctype(value);
			} else if ((value = matches[4]) || matchText === '<!') {
			  index = processMalformedComment(value, matches.index + matchText.length);
			  tokenRegExp.lastIndex = index;
			  continue;
			} else if (value = matches[5]) {
			  if (parsingMode === 1) {
				pi(value, matches[6]);
			  } else {
				index = processMalformedComment('?', matches.index + 2);
				tokenRegExp.lastIndex = index;
				continue;
			  }
			}
			index = matches.index + matchText.length;
		  }
		  if (index < html.length) {
			processText(decode(html.substr(index)));
		  }
		  for (i = stack.length - 1; i >= 0; i--) {
			value = stack[i];
			if (value.valid) {
			  end(value.name);
			}
		  }
		};
		var parse = function (html, format) {
		  if (format === void 0) {
			format = 'html';
		  }
		  parseInternal(extractBase64DataUris(html), format);
		};
		return { parse: parse };
	  };
	//   SaxParser.findEndTag = findMatchingEndTagIndex;

	var AstNode = function () {
		function AstNode(name, type) {
		  this.name = name;
		  this.type = type;
		  if (type === 1) {
			this.attributes = [];
			this.attributes.map = {};
		  }
		}
		AstNode.create = function (name, attrs) {
		  var node = new AstNode(name, typeLookup[name] || 1);
		  if (attrs) {
			each$j(attrs, function (value, attrName) {
			  node.attr(attrName, value);
			});
		  }
		  return node;
		};
		AstNode.prototype.replace = function (node) {
		  var self = this;
		  if (node.parent) {
			node.remove();
		  }
		  self.insert(node, self);
		  self.remove();
		  return self;
		};
		AstNode.prototype.attr = function (name, value) {
		  var self = this;
		  var attrs;
		  if (typeof name !== 'string') {
			if (name !== undefined && name !== null) {
			  each$j(name, function (value, key) {
				self.attr(key, value);
			  });
			}
			return self;
		  }
		  if (attrs = self.attributes) {
			if (value !== undefined) {
			  if (value === null) {
				if (name in attrs.map) {
				  delete attrs.map[name];
				  var i = attrs.length;
				  while (i--) {
					if (attrs[i].name === name) {
					  attrs.splice(i, 1);
					  return self;
					}
				  }
				}
				return self;
			  }
			  if (name in attrs.map) {
				var i = attrs.length;
				while (i--) {
				  if (attrs[i].name === name) {
					attrs[i].value = value;
					break;
				  }
				}
			  } else {
				attrs.push({
				  name: name,
				  value: value
				});
			  }
			  attrs.map[name] = value;
			  return self;
			}
			return attrs.map[name];
		  }
		};
		AstNode.prototype.clone = function () {
		  var self = this;
		  var clone = new AstNode(self.name, self.type);
		  var selfAttrs;
		  if (selfAttrs = self.attributes) {
			var cloneAttrs = [];
			cloneAttrs.map = {};
			for (var i = 0, l = selfAttrs.length; i < l; i++) {
			  var selfAttr = selfAttrs[i];
			  if (selfAttr.name !== 'id') {
				cloneAttrs[cloneAttrs.length] = {
				  name: selfAttr.name,
				  value: selfAttr.value
				};
				cloneAttrs.map[selfAttr.name] = selfAttr.value;
			  }
			}
			clone.attributes = cloneAttrs;
		  }
		  clone.value = self.value;
		  clone.shortEnded = self.shortEnded;
		  return clone;
		};
		AstNode.prototype.wrap = function (wrapper) {
		  var self = this;
		  self.parent.insert(wrapper, self);
		  wrapper.append(self);
		  return self;
		};
		AstNode.prototype.unwrap = function () {
		  var self = this;
		  for (var node = self.firstChild; node;) {
			var next = node.next;
			self.insert(node, self, true);
			node = next;
		  }
		  self.remove();
		};
		AstNode.prototype.remove = function () {
		  var self = this, parent = self.parent, next = self.next, prev = self.prev;
		  if (parent) {
			if (parent.firstChild === self) {
			  parent.firstChild = next;
			  if (next) {
				next.prev = null;
			  }
			} else {
			  prev.next = next;
			}
			if (parent.lastChild === self) {
			  parent.lastChild = prev;
			  if (prev) {
				prev.next = null;
			  }
			} else {
			  next.prev = prev;
			}
			self.parent = self.next = self.prev = null;
		  }
		  return self;
		};
		AstNode.prototype.append = function (node) {
		  var self = this;
		  if (node.parent) {
			node.remove();
		  }
		  var last = self.lastChild;
		  if (last) {
			last.next = node;
			node.prev = last;
			self.lastChild = node;
		  } else {
			self.lastChild = self.firstChild = node;
		  }
		  node.parent = self;
		  return node;
		};
		AstNode.prototype.insert = function (node, refNode, before) {
		  if (node.parent) {
			node.remove();
		  }
		  var parent = refNode.parent || this;
		  if (before) {
			if (refNode === parent.firstChild) {
			  parent.firstChild = node;
			} else {
			  refNode.prev.next = node;
			}
			node.prev = refNode.prev;
			node.next = refNode;
			refNode.prev = node;
		  } else {
			if (refNode === parent.lastChild) {
			  parent.lastChild = node;
			} else {
			  refNode.next.prev = node;
			}
			node.next = refNode.next;
			node.prev = refNode;
			refNode.next = node;
		  }
		  node.parent = parent;
		  return node;
		};
		AstNode.prototype.getAll = function (name) {
		  var self = this;
		  var collection = [];
		  for (var node = self.firstChild; node; node = walk$1(node, self)) {
			if (node.name === name) {
			  collection.push(node);
			}
		  }
		  return collection;
		};
		AstNode.prototype.children = function () {
		  var self = this;
		  var collection = [];
		  for (var node = self.firstChild; node; node = node.next) {
			collection.push(node);
		  }
		  return collection;
		};
		AstNode.prototype.empty = function () {
		  var self = this;
		  if (self.firstChild) {
			var nodes = [];
			for (var node = self.firstChild; node; node = walk$1(node, self)) {
			  nodes.push(node);
			}
			var i = nodes.length;
			while (i--) {
			  var node = nodes[i];
			  node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;
			}
		  }
		  self.firstChild = self.lastChild = null;
		  return self;
		};
		AstNode.prototype.isEmpty = function (elements, whitespace, predicate) {
		  if (whitespace === void 0) {
			whitespace = {};
		  }
		  var self = this;
		  var node = self.firstChild;
		  if (isNonEmptyElement(self)) {
			return false;
		  }
		  if (node) {
			do {
			  if (node.type === 1) {
				if (node.attr('data-mce-bogus')) {
				  continue;
				}
				if (elements[node.name]) {
				  return false;
				}
				if (isNonEmptyElement(node)) {
				  return false;
				}
			  }
			  if (node.type === 8) {
				return false;
			  }
			  if (node.type === 3 && !isEmptyTextNode(node)) {
				return false;
			  }
			  if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText(node.value)) {
				return false;
			  }
			  if (predicate && predicate(node)) {
				return false;
			  }
			} while (node = walk$1(node, self));
		  }
		  return true;
		};
		AstNode.prototype.walk = function (prev) {
		  return walk$1(this, null, prev);
		};
		return AstNode;
	  }();

	  var extractBase64DataUris = function (html) {
		var dataImageUri = /data:[^;]+;base64,([a-z0-9\+\/=\s]+)/gi;
		var chunks = [];
		var uris = {};
		var prefix = generate('img');
		var matches;
		var index = 0;
		var count = 0;
		while (matches = dataImageUri.exec(html)) {
		  var uri = matches[0];
		  var imageId = prefix + '_' + count++;
		  uris[imageId] = uri;
		  if (index < matches.index) {
			chunks.push(html.substr(index, matches.index - index));
		  }
		  chunks.push(imageId);
		  index = matches.index + uri.length;
		}
		var re = new RegExp(prefix + '_[0-9]+', 'g');
		if (index === 0) {
		  return {
			prefix: prefix,
			uris: uris,
			html: html,
			re: re
		  };
		} else {
		  if (index < html.length) {
			chunks.push(html.substr(index));
		  }
		  return {
			prefix: prefix,
			uris: uris,
			html: chunks.join(''),
			re: re
		  };
		}
	  };
	  var restoreDataUris = function (html, result) {
		return html.replace(result.re, function (imageId) {
		  return get$9(result.uris, imageId).getOr(imageId);
		});
	  };
	  var parseDataUri$1 = function (uri) {
		var matches = /data:([^;]+);base64,([a-z0-9\+\/=\s]+)/i.exec(uri);
		if (matches) {
		  return Optional.some({
			type: matches[1],
			data: decodeURIComponent(matches[2])
		  });
		} else {
		  return Optional.none();
		}
	  };

	  var unique = 0;
	  var generate = function (prefix) {
		var date = new Date();
		var time = date.getTime();
		var random = Math.floor(Math.random() * 1000000000);
		unique++;
		return prefix + '_' + random + unique + String(time);
	  };

	  var makeMap$3 = Tools.makeMap;
	  var attrsCharsRegExp = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	  var textCharsRegExp = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	  var rawCharsRegExp = /[<>&\"\']/g;
	  var entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;
	  var asciiMap = {
		128: '\u20AC',
		130: '\u201A',
		131: '\u0192',
		132: '\u201E',
		133: '\u2026',
		134: '\u2020',
		135: '\u2021',
		136: '\u02c6',
		137: '\u2030',
		138: '\u0160',
		139: '\u2039',
		140: '\u0152',
		142: '\u017d',
		145: '\u2018',
		146: '\u2019',
		147: '\u201C',
		148: '\u201D',
		149: '\u2022',
		150: '\u2013',
		151: '\u2014',
		152: '\u02DC',
		153: '\u2122',
		154: '\u0161',
		155: '\u203A',
		156: '\u0153',
		158: '\u017e',
		159: '\u0178'
	  };
	  var baseEntities = {
		'"': '&quot;',
		'\'': '&#39;',
		'<': '&lt;',
		'>': '&gt;',
		'&': '&amp;',
		'`': '&#96;'
	  };
	  var reverseEntities = {
		'&lt;': '<',
		'&gt;': '>',
		'&amp;': '&',
		'&quot;': '"',
		'&apos;': '\''
	  };
	  var nativeDecode = function (text) {
		var elm = SugarElement.fromTag('div').dom;
		elm.innerHTML = text;
		return elm.textContent || elm.innerText || text;
	  };
	  var buildEntitiesLookup = function (items, radix) {
		var i, chr, entity;
		var lookup = {};
		if (items) {
		  items = items.split(',');
		  radix = radix || 10;
		  for (i = 0; i < items.length; i += 2) {
			chr = String.fromCharCode(parseInt(items[i], radix));
			if (!baseEntities[chr]) {
			  entity = '&' + items[i + 1] + ';';
			  lookup[chr] = entity;
			  lookup[entity] = chr;
			}
		  }
		  return lookup;
		}
	  };
	  var namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);
	  var encodeRaw = function (text, attr) {
		return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
		  return baseEntities[chr] || chr;
		});
	  };
	  var encodeAllRaw = function (text) {
		return ('' + text).replace(rawCharsRegExp, function (chr) {
		  return baseEntities[chr] || chr;
		});
	  };
	  var encodeNumeric = function (text, attr) {
		return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
		  if (chr.length > 1) {
			return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';
		  }
		  return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';
		});
	  };
	  var encodeNamed = function (text, attr, entities) {
		entities = entities || namedEntities;
		return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
		  return baseEntities[chr] || entities[chr] || chr;
		});
	  };
	  var getEncodeFunc = function (name, entities) {
		var entitiesMap = buildEntitiesLookup(entities) || namedEntities;
		var encodeNamedAndNumeric = function (text, attr) {
		  return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, function (chr) {
			if (baseEntities[chr] !== undefined) {
			  return baseEntities[chr];
			}
			if (entitiesMap[chr] !== undefined) {
			  return entitiesMap[chr];
			}
			if (chr.length > 1) {
			  return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';
			}
			return '&#' + chr.charCodeAt(0) + ';';
		  });
		};
		var encodeCustomNamed = function (text, attr) {
		  return encodeNamed(text, attr, entitiesMap);
		};
		var nameMap = makeMap$3(name.replace(/\+/g, ','));
		if (nameMap.named && nameMap.numeric) {
		  return encodeNamedAndNumeric;
		}
		if (nameMap.named) {
		  if (entities) {
			return encodeCustomNamed;
		  }
		  return encodeNamed;
		}
		if (nameMap.numeric) {
		  return encodeNumeric;
		}
		return encodeRaw;
	  };
	  var decode = function (text) {
		return text.replace(entityRegExp, function (all, numeric) {
		  if (numeric) {
			if (numeric.charAt(0).toLowerCase() === 'x') {
			  numeric = parseInt(numeric.substr(1), 16);
			} else {
			  numeric = parseInt(numeric, 10);
			}
			if (numeric > 65535) {
			  numeric -= 65536;
			  return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));
			}
			return asciiMap[numeric] || String.fromCharCode(numeric);
		  }
		  return reverseEntities[all] || namedEntities[all] || nativeDecode(all);
		});
	  };
	  var Entities = {
		encodeRaw: encodeRaw,
		encodeAllRaw: encodeAllRaw,
		encodeNumeric: encodeNumeric,
		encodeNamed: encodeNamed,
		getEncodeFunc: getEncodeFunc,
		decode: decode
	  };

	  var isLineBreakNode = function (node, blockElements) {
		return node && (has$2(blockElements, node.name) || node.name === 'br');
	  };

	  var filteredClobberElements = Tools.makeMap('button,fieldset,form,iframe,img,image,input,object,output,select,textarea');
	  var isValidPrefixAttrName = function (name) {
		return name.indexOf('data-') === 0 || name.indexOf('aria-') === 0;
	  };
	  var findMatchingEndTagIndex = function (schema, html, startIndex) {
		var startTagRegExp = /<([!?\/])?([A-Za-z0-9\-_:.]+)/g;
		var endTagRegExp = /(?:\s(?:[^'">]+(?:"[^"]*"|'[^']*'))*[^"'>]*(?:"[^">]*|'[^'>]*)?|\s*|\/)>/g;
		var shortEndedElements = schema.getShortEndedElements();
		var count = 1, index = startIndex;
		while (count !== 0) {
		  startTagRegExp.lastIndex = index;
		  while (true) {
			var startMatch = startTagRegExp.exec(html);
			if (startMatch === null) {
			  return index;
			} else if (startMatch[1] === '!') {
			  if (startsWith(startMatch[2], '--')) {
				index = findCommentEndIndex(html, false, startMatch.index + '!--'.length);
			  } else {
				index = findCommentEndIndex(html, true, startMatch.index + 1);
			  }
			  break;
			} else {
			  endTagRegExp.lastIndex = startTagRegExp.lastIndex;
			  var endMatch = endTagRegExp.exec(html);
			  if (isNull(endMatch) || endMatch.index !== startTagRegExp.lastIndex) {
				continue;
			  }
			  if (startMatch[1] === '/') {
				count -= 1;
			  } else if (!has$2(shortEndedElements, startMatch[2])) {
				count += 1;
			  }
			  index = startTagRegExp.lastIndex + endMatch[0].length;
			  break;
			}
		  }
		}
		return index;
	  };
	  var isConditionalComment = function (html, startIndex) {
		return /^\s*\[if [\w\W]+\]>.*<!\[endif\](--!?)?>/.test(html.substr(startIndex));
	  };
	  var findCommentEndIndex = function (html, isBogus, startIndex) {
		if (startIndex === void 0) {
		  startIndex = 0;
		}
		var lcHtml = html.toLowerCase();
		if (lcHtml.indexOf('[if ', startIndex) !== -1 && isConditionalComment(lcHtml, startIndex)) {
		  var endIfIndex = lcHtml.indexOf('[endif]', startIndex);
		  return lcHtml.indexOf('>', endIfIndex);
		} else {
		  if (isBogus) {
			var endIndex = lcHtml.indexOf('>', startIndex);
			return endIndex !== -1 ? endIndex : lcHtml.length;
		  } else {
			var endCommentRegexp = /--!?>/g;
			endCommentRegexp.lastIndex = startIndex;
			var match = endCommentRegexp.exec(html);
			return match ? match.index + match[0].length : lcHtml.length;
		  }
		}
	  };

	  var checkBogusAttribute = function (regExp, attrString) {
		var matches = regExp.exec(attrString);
		if (matches) {
		  var name_1 = matches[1];
		  var value = matches[2];
		  return typeof name_1 === 'string' && name_1.toLowerCase() === 'data-mce-bogus' ? value : null;
		} else {
		  return null;
		}
	  };

	  var typeLookup = {
		'#text': 3,
		'#comment': 8,
		'#cdata': 4,
		'#pi': 7,
		'#doctype': 10,
		'#document-fragment': 11
	  };
	  var walk$1 = function (node, root, prev) {
		var startName = prev ? 'lastChild' : 'firstChild';
		var siblingName = prev ? 'prev' : 'next';
		if (node[startName]) {
		  return node[startName];
		}
		if (node !== root) {
		  var sibling = node[siblingName];
		  if (sibling) {
			return sibling;
		  }
		  for (var parent_1 = node.parent; parent_1 && parent_1 !== root; parent_1 = parent_1.parent) {
			sibling = parent_1[siblingName];
			if (sibling) {
			  return sibling;
			}
		  }
		}
	  };
	  var isEmptyTextNode = function (node) {
		if (!isWhitespaceText(node.value)) {
		  return false;
		}
		var parentNode = node.parent;
		if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(node.value)) {
		  return false;
		}
		return true;
	  };
	  var isNonEmptyElement = function (node) {
		var isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');
		return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;
	  };

	  var compileElementMap = function (value, mode) {
		var styles;
		if (value) {
		  styles = {};
		  if (typeof value === 'string') {
			value = { '*': value };
		  }
		  each$h(value, function (value, key) {
			styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$3(value, /[, ]/);
		  });
		}
		return styles;
	  };

	  var makeMap = Tools.makeMap, each$6 = Tools.each, explode$2 = Tools.explode, extend$4 = Tools.extend;
	  var DomParser = function (settings, schema) {
		if (schema === void 0) {
		  schema = Schema();
		}
		var nodeFilters = {};
		var attributeFilters = [];
		var matchedNodes = {};
		var matchedAttributes = {};
		settings = settings || {};
		settings.validate = 'validate' in settings ? settings.validate : true;
		settings.root_name = settings.root_name || 'body';
		var fixInvalidChildren = function (nodes) {
		  var nonSplitableElements = makeMap('tr,td,th,tbody,thead,tfoot,table');
		  var nonEmptyElements = schema.getNonEmptyElements();
		  var whitespaceElements = schema.getWhiteSpaceElements();
		  var textBlockElements = schema.getTextBlockElements();
		  var specialElements = schema.getSpecialElements();
		  var removeOrUnwrapInvalidNode = function (node, originalNodeParent) {
			if (originalNodeParent === void 0) {
			  originalNodeParent = node.parent;
			}
			if (specialElements[node.name]) {
			  node.empty().remove();
			} else {
			  var children = node.children();
			  for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
				var childNode = children_1[_i];
				if (!schema.isValidChild(originalNodeParent.name, childNode.name)) {
				  removeOrUnwrapInvalidNode(childNode, originalNodeParent);
				}
			  }
			  node.unwrap();
			}
		  };
		  for (var ni = 0; ni < nodes.length; ni++) {
			var node = nodes[ni];
			var parent_1 = void 0, newParent = void 0, tempNode = void 0;
			if (!node.parent || node.fixed) {
			  continue;
			}
			if (textBlockElements[node.name] && node.parent.name === 'li') {
			  var sibling = node.next;
			  while (sibling) {
				if (textBlockElements[sibling.name]) {
				  sibling.name = 'li';
				  sibling.fixed = true;
				  node.parent.insert(sibling, node.parent);
				} else {
				  break;
				}
				sibling = sibling.next;
			  }
			  node.unwrap();
			  continue;
			}
			var parents = [node];
			for (parent_1 = node.parent; parent_1 && !schema.isValidChild(parent_1.name, node.name) && !nonSplitableElements[parent_1.name]; parent_1 = parent_1.parent) {
			  parents.push(parent_1);
			}
			if (parent_1 && parents.length > 1) {
			  if (schema.isValidChild(parent_1.name, node.name)) {
				parents.reverse();
				newParent = filterNode(parents[0].clone());
				var currentNode = newParent;
				for (var i = 0; i < parents.length - 1; i++) {
				  if (schema.isValidChild(currentNode.name, parents[i].name)) {
					tempNode = filterNode(parents[i].clone());
					currentNode.append(tempNode);
				  } else {
					tempNode = currentNode;
				  }
				  for (var childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {
					var nextNode = childNode.next;
					tempNode.append(childNode);
					childNode = nextNode;
				  }
				  currentNode = tempNode;
				}
				if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {
				  parent_1.insert(newParent, parents[0], true);
				  parent_1.insert(node, newParent);
				} else {
				  parent_1.insert(node, parents[0], true);
				}
				parent_1 = parents[0];
				if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent_1) || hasOnlyChild(parent_1, 'br')) {
				  parent_1.empty().remove();
				}
			  } else {
				removeOrUnwrapInvalidNode(node);
			  }
			} else if (node.parent) {
			  if (node.name === 'li') {
				var sibling = node.prev;
				if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {
				  sibling.append(node);
				  continue;
				}
				sibling = node.next;
				if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {
				  sibling.insert(node, sibling.firstChild, true);
				  continue;
				}
				node.wrap(filterNode(new AstNode('ul', 1)));
				continue;
			  }
			  if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {
				node.wrap(filterNode(new AstNode('div', 1)));
			  } else {
				removeOrUnwrapInvalidNode(node);
			  }
			}
		  }
		};
		var filterNode = function (node) {
		  var name = node.name;
		  if (name in nodeFilters) {
			var list = matchedNodes[name];
			if (list) {
			  list.push(node);
			} else {
			  matchedNodes[name] = [node];
			}
		  }
		  var i = attributeFilters.length;
		  while (i--) {
			var attrName = attributeFilters[i].name;
			if (attrName in node.attributes.map) {
			  var list = matchedAttributes[attrName];
			  if (list) {
				list.push(node);
			  } else {
				matchedAttributes[attrName] = [node];
			  }
			}
		  }
		  return node;
		};
		var addNodeFilter = function (name, callback) {
		  each$6(explode$2(name), function (name) {
			var list = nodeFilters[name];
			if (!list) {
			  nodeFilters[name] = list = [];
			}
			list.push(callback);
		  });
		};
		var getNodeFilters = function () {
		  var out = [];
		  for (var name_1 in nodeFilters) {
			if (has$2(nodeFilters, name_1)) {
			  out.push({
				name: name_1,
				callbacks: nodeFilters[name_1]
			  });
			}
		  }
		  return out;
		};
		var addAttributeFilter = function (name, callback) {
		  each$6(explode$2(name), function (name) {
			var i;
			for (i = 0; i < attributeFilters.length; i++) {
			  if (attributeFilters[i].name === name) {
				attributeFilters[i].callbacks.push(callback);
				return;
			  }
			}
			attributeFilters.push({
			  name: name,
			  callbacks: [callback]
			});
		  });
		};
		var getAttributeFilters = function () {
		  return [].concat(attributeFilters);
		};
		var parse = function (html, args) {
		  var nodes, i, l, fi, fl, list, name;
		  var invalidChildren = [];
		  var node;
		  var getRootBlockName = function (name) {
			if (name === false) {
			  return '';
			} else if (name === true) {
			  return 'p';
			} else {
			  return name;
			}
		  };
		  args = args || {};
		  matchedNodes = {};
		  matchedAttributes = {};
		  var blockElements = extend$4(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());
		  var nonEmptyElements = schema.getNonEmptyElements();
		  var children = schema.children;
		  var validate = settings.validate;
		  var forcedRootBlockName = 'forced_root_block' in args ? args.forced_root_block : settings.forced_root_block;
		  var rootBlockName = getRootBlockName(forcedRootBlockName);
		  var whiteSpaceElements = schema.getWhiteSpaceElements();
		  var startWhiteSpaceRegExp = /^[ \t\r\n]+/;
		  var endWhiteSpaceRegExp = /[ \t\r\n]+$/;
		  var allWhiteSpaceRegExp = /[ \t\r\n]+/g;
		  var isAllWhiteSpaceRegExp = /^[ \t\r\n]+$/;
		  var isInWhiteSpacePreservedElement = has$2(whiteSpaceElements, args.context) || has$2(whiteSpaceElements, settings.root_name);
		  var addRootBlocks = function () {
			var node = rootNode.firstChild, rootBlockNode = null;
			var trim = function (rootBlock) {
			  if (rootBlock) {
				node = rootBlock.firstChild;
				if (node && node.type === 3) {
				  node.value = node.value.replace(startWhiteSpaceRegExp, '');
				}
				node = rootBlock.lastChild;
				if (node && node.type === 3) {
				  node.value = node.value.replace(endWhiteSpaceRegExp, '');
				}
			  }
			};
			if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {
			  return;
			}
			while (node) {
			  var next = node.next;
			  if (node.type === 3 || node.type === 1 && node.name !== 'p' && !blockElements[node.name] && !node.attr('data-mce-type')) {
				if (!rootBlockNode) {
				  rootBlockNode = createNode(rootBlockName, 1);
				  rootBlockNode.attr(settings.forced_root_block_attrs);
				  rootNode.insert(rootBlockNode, node);
				  rootBlockNode.append(node);
				} else {
				  rootBlockNode.append(node);
				}
			  } else {
				trim(rootBlockNode);
				rootBlockNode = null;
			  }
			  node = next;
			}
			trim(rootBlockNode);
		  };
		  var createNode = function (name, type) {
			var node = new AstNode(name, type);
			var list;
			if (name in nodeFilters) {
			  list = matchedNodes[name];
			  if (list) {
				list.push(node);
			  } else {
				matchedNodes[name] = [node];
			  }
			}
			return node;
		  };
		  var removeWhitespaceBefore = function (node) {
			var blockElements = schema.getBlockElements();
			for (var textNode = node.prev; textNode && textNode.type === 3;) {
			  var textVal = textNode.value.replace(endWhiteSpaceRegExp, '');
			  if (textVal.length > 0) {
				textNode.value = textVal;
				return;
			  }
			  var textNodeNext = textNode.next;
			  if (textNodeNext) {
				if (textNodeNext.type === 3 && textNodeNext.value.length) {
				  textNode = textNode.prev;
				  continue;
				}
				if (!blockElements[textNodeNext.name] && textNodeNext.name !== 'script' && textNodeNext.name !== 'style') {
				  textNode = textNode.prev;
				  continue;
				}
			  }
			  var sibling = textNode.prev;
			  textNode.remove();
			  textNode = sibling;
			}
		  };
		  var cloneAndExcludeBlocks = function (input) {
			var output = {};
			for (var name_2 in input) {
			  if (name_2 !== 'li' && name_2 !== 'p') {
				output[name_2] = input[name_2];
			  }
			}
			return output;
		  };
		  var parser = SaxParser({
			validate: validate,
			document: settings.document,
			allow_html_data_urls: settings.allow_html_data_urls,
			allow_svg_data_urls: settings.allow_svg_data_urls,
			allow_script_urls: settings.allow_script_urls,
			allow_conditional_comments: settings.allow_conditional_comments,
			preserve_cdata: settings.preserve_cdata,
			self_closing_elements: cloneAndExcludeBlocks(schema.getSelfClosingElements()),
			cdata: function (text) {
			  node.append(createNode('#cdata', 4)).value = text;
			},
			text: function (text, raw) {
			  var textNode;
			  if (!isInWhiteSpacePreservedElement) {
				text = text.replace(allWhiteSpaceRegExp, ' ');
				if (isLineBreakNode(node.lastChild, blockElements)) {
				  text = text.replace(startWhiteSpaceRegExp, '');
				}
			  }
			  if (text.length !== 0) {
				textNode = createNode('#text', 3);
				textNode.raw = !!raw;
				node.append(textNode).value = text;
			  }
			},
			comment: function (text) {
			  node.append(createNode('#comment', 8)).value = text;
			},
			pi: function (name, text) {
			  node.append(createNode(name, 7)).value = text;
			  removeWhitespaceBefore(node);
			},
			doctype: function (text) {
			  var newNode = node.append(createNode('#doctype', 10));
			  newNode.value = text;
			  removeWhitespaceBefore(node);
			},
			start: function (name, attrs, empty) {
			  var elementRule = validate ? schema.getElementRule(name) : {};
			  if (elementRule) {
				var newNode = createNode(elementRule.outputName || name, 1);
				newNode.attributes = attrs;
				newNode.shortEnded = empty;
				node.append(newNode);
				var parent_2 = children[node.name];
				if (parent_2 && children[newNode.name] && !parent_2[newNode.name]) {
				  invalidChildren.push(newNode);
				}
				var attrFiltersLen = attributeFilters.length;
				while (attrFiltersLen--) {
				  var attrName = attributeFilters[attrFiltersLen].name;
				  if (attrName in attrs.map) {
					list = matchedAttributes[attrName];
					if (list) {
					  list.push(newNode);
					} else {
					  matchedAttributes[attrName] = [newNode];
					}
				  }
				}
				if (blockElements[name]) {
				  removeWhitespaceBefore(newNode);
				}
				if (!empty) {
				  node = newNode;
				}
				if (!isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {
				  isInWhiteSpacePreservedElement = true;
				}
			  }
			},
			end: function (name) {
			  var textNode, text, sibling, tempNode;
			  var elementRule = validate ? schema.getElementRule(name) : {};
			  if (elementRule) {
				if (blockElements[name]) {
				  if (!isInWhiteSpacePreservedElement) {
					textNode = node.firstChild;
					if (textNode && textNode.type === 3) {
					  text = textNode.value.replace(startWhiteSpaceRegExp, '');
					  if (text.length > 0) {
						textNode.value = text;
						textNode = textNode.next;
					  } else {
						sibling = textNode.next;
						textNode.remove();
						textNode = sibling;
						while (textNode && textNode.type === 3) {
						  text = textNode.value;
						  sibling = textNode.next;
						  if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
							textNode.remove();
							textNode = sibling;
						  }
						  textNode = sibling;
						}
					  }
					}
					textNode = node.lastChild;
					if (textNode && textNode.type === 3) {
					  text = textNode.value.replace(endWhiteSpaceRegExp, '');
					  if (text.length > 0) {
						textNode.value = text;
						textNode = textNode.prev;
					  } else {
						sibling = textNode.prev;
						textNode.remove();
						textNode = sibling;
						while (textNode && textNode.type === 3) {
						  text = textNode.value;
						  sibling = textNode.prev;
						  if (text.length === 0 || isAllWhiteSpaceRegExp.test(text)) {
							textNode.remove();
							textNode = sibling;
						  }
						  textNode = sibling;
						}
					  }
					}
				  }
				}
				if (isInWhiteSpacePreservedElement && whiteSpaceElements[name]) {
				  isInWhiteSpacePreservedElement = false;
				}
				if (elementRule.removeEmpty && isEmpty(schema, nonEmptyElements, whiteSpaceElements, node)) {
				  tempNode = node.parent;
				  if (blockElements[node.name]) {
					node.empty().remove();
				  } else {
					node.unwrap();
				  }
				  node = tempNode;
				  return;
				}
				if (elementRule.paddEmpty && (isPaddedWithNbsp(node) || isEmpty(schema, nonEmptyElements, whiteSpaceElements, node))) {
				  paddEmptyNode(settings, args, blockElements, node);
				}
				node = node.parent;
			  }
			}
		  }, schema);
		  var rootNode = node = new AstNode(args.context || settings.root_name, 11);
		  parser.parse(html, args.format);
		  if (validate && invalidChildren.length) {
			if (!args.context) {
			  fixInvalidChildren(invalidChildren);
			} else {
			  args.invalid = true;
			}
		  }
		  if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {
			addRootBlocks();
		  }
		  if (!args.invalid) {
			for (name in matchedNodes) {
			  if (!has$2(matchedNodes, name)) {
				continue;
			  }
			  list = nodeFilters[name];
			  nodes = matchedNodes[name];
			  fi = nodes.length;
			  while (fi--) {
				if (!nodes[fi].parent) {
				  nodes.splice(fi, 1);
				}
			  }
			  for (i = 0, l = list.length; i < l; i++) {
				list[i](nodes, name, args);
			  }
			}
			for (i = 0, l = attributeFilters.length; i < l; i++) {
			  list = attributeFilters[i];
			  if (list.name in matchedAttributes) {
				nodes = matchedAttributes[list.name];
				fi = nodes.length;
				while (fi--) {
				  if (!nodes[fi].parent) {
					nodes.splice(fi, 1);
				  }
				}
				for (fi = 0, fl = list.callbacks.length; fi < fl; fi++) {
				  list.callbacks[fi](nodes, list.name, args);
				}
			  }
			}
		  }
		  return rootNode;
		};
		var exports = {
		  schema: schema,
		  addAttributeFilter: addAttributeFilter,
		  getAttributeFilters: getAttributeFilters,
		  addNodeFilter: addNodeFilter,
		  getNodeFilters: getNodeFilters,
		  filterNode: filterNode,
		  parse: parse
		};
		register$1(exports, settings);
		register$2(exports, settings);
		return exports;
	  };

	// ---------------------------------------------------


	 var Plugin = () => {
		pluginGlobal$4.add('fullpage', editor => {
			var headState = Cell(''), footState = Cell('');
			pluginRegister$1(editor, headState);
			pluginRegister(editor);
			setup(editor, headState, footState);
		  return {};
		});
	  };

    Plugin();

}());
